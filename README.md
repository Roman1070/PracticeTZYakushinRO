# Комментарий

Сделал job worker с настройкой таймаутов и ретраев.
Паузу не придумал куда всталвять, но т.к. использовал контекст, ее легко будет добавить при необходимости.
Для интеграции достаточно поменять сиганутуру функции Job и вызывать функицю с новыми параметрами.
Также сделал перезапуск невыполненных задач (они возвращаются в очередь при выполнении с ошибкой) и симуляцию ошибок в http запросах, чтобы удобнее было тестировать.
Все статусы решил хранить в map, чтобы можно было получить статус даже завершенных процессов.

**Содержимое .env файла**
CONFIG_PATH=./configs/local.yaml
APP_PORT=":8000"

# Задание

Требуется создать job worker для обработки фоновых задач на языке Go.
Это должна быть лёгкая, отказоустойчивая система с возможностью обработки задач в очереди.
Необходимо реализовать очередь задач, несколько воркеров для параллельной обработки, гибкую настройку (таймауты, ретраи, паузы) и предусмотреть возможность для интеграции.
Задача со звездочкой - очередь задач с приоритетами, перезапуск невыполненных (по какой-либо причине) задач

Можно взять любую очередь сообщений, а также любой формат сообщения

Ограничения:

Количество задач в минуту - 100

Каждая задача выполняется максимум 3 секунды. Можно воспользоваться функцией:

```go
func PerformJob(name string, jobData []byte) error {
    fmt.Printf("Started job %s at %d", name, time.Now().UnixMilli())

    // do some work. Random sleep time; max = 3s
    <-time.After(time.Duration(rand.Int63n(int64(3 * time.Second))))

    fmt.Printf("Finished job %s at %d", name, time.Now().UnixMilli())
    return nil
}
```

Критерии приемки:

1. Есть endpoint `POST /job` или `PUT /job/{job_id}`, по которому я могу поставить задачу в очередь
2. Есть endpoint `GET /job/{job_id}`, по которому я могу получить текущий статус задачи
3. Запуск системы происходит в докере/в кубере
